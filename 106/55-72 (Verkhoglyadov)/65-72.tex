\documentclass{./git_rep/mai_prac_2017/template/mai_book}
\defaultfontfeatures{Mapping=tex-text}
\setdefaultlanguage{russian}
\usepackage{multicol}

\clearpage
\setcounter{page}{65} % ВОТ ТУТ ЗАДАТЬ СТРАНИЦУ
\setcounter{section}{3} % ТАК ЗАДАВАТЬ ГЛАВЫ, ПАРАГРАФЫ И ПРОЧЕЕ.
\setcounter{subsection}{1}
%55-72

\begin{document}
%                                  65
В качестве первой иллюстрации принципа шаблонов мы покажем,\linebreak
как в языке Ада построить процедуры или функции, число аргументов\linebreak
которых кажется переменным. Этот метод использования шаблонов не\linebreak
очень принят,  но дает блестящие результаты в задачах такого вида\linebreak
(см.  работу Буха [27]).  Выбранный нами этого пример является по-\linebreak
строением функции, позволяющей находить ее  наибольший аргумент\linebreak
(среди любого их количества). Для начала рассмотрим массив,  в ко­-\linebreak
тором множество индексов (подынтервал целых положительных чисел)\linebreak
и тип основных элементов произвольны. Массив называется $T$, а тип\linebreak
элементов массива $-$ $Object$. Так как мы ничего не знаем о типе элемен-\linebreak
тов, то если мы хотим вычислить максимум элементов массива, нужно\linebreak
располагать оператором сравнения; этот оператор обозначен <<$<$>>. Вы-\linebreak
числяемое значение $Max$ должно удовлетворять условию:
\begin{center}
при любом индексе $i$ массива $T$: $T(i)=Max$ или $T(i)<Max$.
\end{center}
В этом  выражении  внимательный  читатель  отметит  использование\linebreak
двух операторов,  <<$=$>>  и  <<$<$>>,  а не единственного оператора <<$\leqslant$>>:  про-\linebreak
граммистская шероховатость, которая будет сглажена при реализации\linebreak
этой функции в языке Ада.  Алгоритм вычисления  максимума очень\linebreak
прост, и нет необходимости его подробно объяснять. Итак, предлага-\linebreak
ем сразу реализацию этой функции в языке Ада, учитывая тот факт,\linebreak
что единственные допустимые операции на элементах типа $Object$ $-$\linebreak
это: описание, присваивание и сравнение оператором <<$<$>>.
\begin{lstlisting}[mathescape=true, language=Ada, frame=none, xleftmargin=20pt]
function $Max (T : Objects\_Array)$ return $Object$ is
 $Temporary\_Maximum : Object := T (T`First)$;
begin
 for $i$ in $T`First+1 .. T`Last$ loop
  if $Temporary\_Maximum<T(i)$ then $Temporary\_Maximum := T(i)$;
  end if;
 end loop;
 return $Temporary\_Maximum$;
end $Max$;
\end{lstlisting}
Основная характеристика этой части Ада-программы $-$ это полное от-\linebreak
сутствие явной ссылки на любое особое свойство обрабатываемого мас-\linebreak
сива: точно не известно, каковы индексы массива, и также не известны\linebreak
элементы, составляющие массив, а единственные используемые опера-\linebreak
ции $-$ это три операции, названные выше. Однако можно обработать\linebreak
массив, обработать его границы благодаря предопределенным функ-\linebreak
циям в языке Ада, которые называют \textit{атрибутами}. Таким образом,\linebreak
если $T$ $-$ массив, выражение $T`First$ обозначает наименьший  индекс\linebreak
массива $T$, a $T`Last$ обозначает наибольший индекс $T$. Это доказыва-\linebreak
\newpage

%                                  66
\noindent
ет, что функция, имеющая массив в качестве формального параметра,\linebreak
может каждый раз заново определять некоторые характеристики мас-\linebreak
сива,  который ей  передан  в качестве фактического параметра (длина,\linebreak
границы...):  атрибуты позволяют определить эти характеристики \textit{ди}-\linebreak
\textit{намически}, т.е. во время выполнения. Хотя это явно не выражено, но в\linebreak
этой  функции  используется  особое  свойство  индексов:  их  целочислен-\linebreak
ный характер, который позволяет записать выражение $T`First+1$.\newline
\hspace*{15pt}Логическое  следствие  всего  этого  заключается  в  том,  что  текст\linebreak
функции $Max$ всегда один и тот же и что обрабатываемые объекты $-$\linebreak
это  целые  числа,  действительные  числа,  литералы  перечисления  или\linebreak
любой другой объект при условии,  что пользователь задаст операцию\linebreak
сравнения. Другими словами, очень легко записать на основе всего ска-\linebreak
занного настраиваемый алгоритм вычисления максимума. Таким обра-\linebreak
зом, спецификация, обозначения которой слегка отличаются от преды-\linebreak
дущих, выглядит так:
\begin{center}
\textit{Спецификация настраиваемого алгоритма вычисления максимума}
\end{center}
\begin{lstlisting}[mathescape=true, language=Ada]
generic
    type $Object$ is private;
    with $Function "<" (a,b : Object)$ return $Boolean$ is $<>$;
package $Maximum$ is
    type $Objects\_Array$ is array $(Positive$ range $<>)$ of $Object$;
    function $Max (T : Objects\_Array)$ return $Object$;
end $Maximum$;
\end{lstlisting}
\hspace*{15pt}Рассмотрим сначала формальные  параметры  настройки  для этого\linebreak
пакета. Тип $Object$ $-$ это приватный тип; это означает, как мы видели\linebreak
в  разделе  3.3  (стр.  53),  что  единственными  операциями,  допустимы-\linebreak
ми неявно внутри пакета на объектах этого типа, являются описание,\linebreak
присваивание,  тест  на  равенство  и  использование  в  качестве  параме-\linebreak
тра  подпрограммы.  Следовательно,  разработчик  функции $Max$ ниче-\linebreak
го  не  знает  о  типе $Object$; он  не  может знать,  идет  ли  речь  о  целом\linebreak
типе,  последовательности  знаков...  Второй  формальный  параметр $-$\linebreak
это оператор сравнения элементов типа $Object$, необходимый для вычи-\linebreak
сления максимального значения,  но который невозможно прямо ввести\linebreak
из-за  незнания  типа $Object$. Кроме  того,  этот  формальный  параметр\linebreak
настройки  имеет  значение  по  умолчанию;  описание $\blacktriangleright$ \textbf{with function}\linebreak
$"<" (a,b : Object)$ \textbf{return} $Boolean$ is $<>; \blacktriangleleft$ означает,  что в случае,  ко-\linebreak
гда пользователь настраиваемого пакета не задает явно эту  функцию\linebreak
в момент конкретизации, то функция, которая должна быть использо-\linebreak
вана, — это функция $<$, имеющая соответствующий тип параметров и\linebreak
видимая в  месте  конкретизации.  Формальным параметрам настройки\linebreak
\newpage
%                                  67
\noindent
могут быть заданы другие виды значений по умолчанию, в дальнейшем\linebreak
мы еще с ними встретимся.\\

Имея эти два параметра, разработчик функции $Max$ задает пользо-\linebreak
вателю, с одной стороны, тип $Objects\_Array$, который, в основном, не\linebreak
будет использоваться,  и функцию $Max$, которая нас интересует.  Тип\linebreak
$Objects\_Array$ служит только для описания типа параметров функции\linebreak
$Max$. Как будет видно в применении функции, пользователь может его\linebreak
полностью игнорировать. Описание типа $Objects\_Array$ $-$ это несколько\linebreak
своеобразное описание массива: $\blacktriangleright$ \textbf{type} $Objects\_Array$ \textbf{is array} $(Positive$\linebreak
\textbf{range}<>$)$ \textbf{of} $Object;\blacktriangleleft$. Это будет точное описание шаблона, и говорить\linebreak
о типе, имеющем отношение к идентификатору $Object\_Array$, значит\linebreak
злоупотреблять языком. Действительно, невозможно описать перемен-\linebreak
иые типа $Object\_Array$, потому что Ада, как любой другой язык, дол-\linebreak
жен иметь возможность предоставить в памяти место, необходимое для\linebreak
массива. Впрочем, вполне возможно использовать этот шаблон для опи-\linebreak
сания типа формальных параметров подпрограммы: при фактическом\linebreak
использовании подпрограммы ее параметрами будут описанные пере-\linebreak
менные (обратное было бы удивительным) или выражения, построен-\linebreak
ные в момент вызова, характеристики которых хорошо известны, когда\linebreak
контроль идет внутри подпрограммы.\\

Тело пакета $Maximum$ записывается прямо, непосредственно и явля­-\linebreak
ется, по существу, ни чем иным, как переформулировкой функции $Max$,\linebreak
представленной выше.
\begin{center}
\textit{Реализация функции Max}
\end{center}
\begin{lstlisting}[mathescape=true, language=Ada, xleftmargin=15pt]
package body $Maximum$ is
 function $Max (T : Objects\_Array)$ return $Object$ is
  $Temporary\_Maximum : Object := T (T`First)$;
 begin
  for $i$ in $T`First+1 .. T`Last$ loop
   if $Temporary\_Maximum < T(i)$ then $Temporary\_Maximum := T(i);$ end if;
  end loop;
 return $Temporary\_Maximum$;
 end $Max$;
end $Maximum$;
\end{lstlisting}
\hspace*{15pt}Перейдем теперь к использованию этой функции. Неинтересно по-\linebreak
дробно объяснять всю программу, использующую эту функцию (в са-\linebreak
мом деле, длина такой программы была бы огромной по сравнению с\linebreak
необходимым пояснением функции $Max$), однако несколько фрагментов\linebreak
такой программы разъяснят возможности функции.
\newpage
%                                  68
\begin{lstlisting}[mathescape=true, language=Ada, frame=none, xleftmargin=15pt]
with $Maximum;--$ Продолжение контекста компиляции
procedure $Using\_Function\_Max$ is
 type $My\_Integer$ is $...-- \text{ В этом месте уже определен оператор "<"}$
                         $\text{на целых числах типа Integer}$
 package $Integer\_Maximum$ is new $Maximum (My\_Integer)$;
                         use $Integer\_Maximum$;
 $x , a , b , c , d : My\_Integer;--\text{ Продолжение}$
                        $\text{описаний (переменные, типы ...)}$
begin
 $--\text{ Начало вычислений}$
 $x := Max ((a,b,c));--\text{ Продолжение вычислений}$
 $x := Max ((a,b,c,d));--\text{ Конец вычислений}$
end $Using\_Function\_Max$;
\end{lstlisting}
\hspace*{15pt}Эта программа использует конкретизацию пакета $Maximum$ для це-\linebreak
лых чисел; как видим, она начинается с оператора контекста (может\linebreak
быть неполного в примере), ссылающегося на настраиваемый пакет.\linebreak
Внутри главной процедуры после определения  целого типа, который\linebreak
наследует обычные операции на целых числах, и в частности, опера-\linebreak
тор сравнения <<$<$>>, находим конкретизацию настраиваемого пакета, в\linebreak
которой задан только фактический параметр, соответствующий типу\linebreak
$Object$; так как второй параметр явно не задан, при конкретизации для\linebreak
него используется значение по умолчанию, т.е. стандартный оператор\linebreak
<<$<$>> сравнения целых чисел. Можно уже заметить, что если бы вместо\linebreak
использования оператора <<$<$>> передали  в качестве второго параметра\linebreak
оператор <<$>$>>, как в команде
\begin{lstlisting}[mathescape=true, frame=none, language=Ada, xleftmargin=15pt]
package $Integer\_Minimum$ is new $Maximum (My\_Integer, ">")$;
\end{lstlisting}
то построенная таким образом функция $Max$ вычислила бы наименьший\linebreak
из своих аргументов, а не наибольший.\newline
\hspace*{15pt}После спецификатора видимости $\blacktriangleright$ \textbf{use} $Integer\_Maximum \blacktriangleleft$ и не-\linebreak
скольких дополнительных описаний находим тело главной процедуры,\linebreak
которое содержит определенное количество дополнительных вычисле-\linebreak
ний и (что нас интересует) два обращения к функции $Max$:
\begin{lstlisting}[mathescape=true, language=Ada, frame=none, xleftmargin=15pt]
$x:=max ((a,b,c)); x:=max ((a,b,c,d))$;
\end{lstlisting}
Выражения,  которые  образуют  фактические  параметры  этих  двух\linebreak
обращений,  являются \textit{агрегатами}, т.е.  явными  структурными\linebreak
конструкциями.  Фактический  параметр первого обращения  к функ-\linebreak
ции $Max$ $-$ это агрегат $(a,b,c)$, который вне своего контекста пред­-\linebreak
ставляет структуру с тремя компонентами типа $My\_Integer$. Это вы-\linebreak
ражение  (агрегат) совместимо с точки зрения типа как с записью с\linebreak
тремя полями типа $My\_Integer$, так и с индексируемым типом с тремя\linebreak
компонентами,  индексы  которого абсолютно произвольны.  Контекст\linebreak
\newpage
%                                  69
\noindent
использования  этого  агрегата  определяет  точным  образом  тип  выра-\linebreak
жения $(a,b,c)$: так как это параметр функции $Max$, то мы имеем  дело с\linebreak
индексируемым  типом  с  тремя  компонентами  (потому  что  в  агрегате\linebreak
их три),  индексированным посредством подынтервала типа $Positive$. О\linebreak 
нем  больше  ничего  не  известно,  и  точное  определение  данного  интер-\linebreak
вала  не  представляет  здесь  никакого  интереса  (за  дополнительными\linebreak
сведениями читатель может обратиться к $ARM$). В этих условиях вто-\linebreak
рой  вызов  функции $Max$ существенно  не  отличается  от  первого:  эта\linebreak
функция  может  применяться  к  массивам  любой  длины,  и  если  бы  не\linebreak
перегруженность  скобками,  то  можно  было  бы  сказать,  что  функция\linebreak
$Max$ обладает переменным  числом  параметров.\newline
\hspace*{15pt}Теперь  должно быть ясно,  что  пользователю этой  функции  нет  не-\linebreak
обходимости представлять тип $Objects\_Array$ в программе; один из слу-\linebreak
чаев, когда это будет необходимо, соответствует использованию функ-\linebreak
ции $Max$, применяемой к \textit{переменной} индексируемого  типа,  но это уже\linebreak
другая  история...
\subsection{4.2 Работа с матрицами}
\noindent
Следующий этап обучения обработке массивов в языке Ада заключает-\linebreak
ся  в  изучении  представления  матриц,  базовых операций  над  матрица-\linebreak
ми,  ввода-вывода  матриц  $-$  короче,  в  определении  так  называемого\linebreak
\textbf{абстрактного  типа  данных} и  в  построении  нескольких  средств\linebreak
управления  такого типа.\newline
\hspace*{15pt}Первая  фаза $-$  определение  абстрактного  типа  данных $-$ начина-\linebreak
ется с распознавания того, что называют простейшими  операциями на\linebreak
типе.  Сначала можно отметить,  что эти  операции  подразделяются  на\linebreak
два вида: \textbf{конструкторы } и \textbf{селекторы}\footnote{
Эта терминология кажется повсюду принята программистами, она произо-\linebreak
шла из разработки технологии программного обеспечения. Можно обратиться к\linebreak
книге Буха $[27]$, которая дает более полные определения с последующим стилем\linebreak
программирования.}. Конструкторы $-$ это опера-\linebreak
ции,  которые  модифицируют состояние  (значение)  данных,  тогда как\linebreak
селекторы  позволяют только узнать это состояние.\newline
\hspace*{15pt}Каковы  же  будут фундаментальные операции,  когда объект $-$  ма-\linebreak
трица?  Прежде  всего,  имеется  конструктор,  который  позволяет  при-\linebreak
сваивать значение элементу матрицы,  а также симметричная операция\linebreak
селектор,  позволяющий  узнать  значение  одного  из  элементов.  Напри\linebreak
мер,  если $A - $ рассматриваемая  матрица,  а $a_{ij}-$ интересующий  нас\linebreak
элемент, то обычно обозначаем $A(i,j)\longleftarrow v$ и $v\longleftarrow A(i,j)$ те действия,\linebreak
которые реализуют эти операции. Но такой способ действия имеет мно-\linebreak
\newpage

%                                  70
\noindent
го последствий и, в частности, приводит к тому, что матрицы всегда\linebreak
представляются с помощью массивов. Однако хорошо известно, что это\linebreak
не так! Некоторые матрицы $-$ разреженные: матрицы, у которых толь-\linebreak
ко небольшое количество элементов не равно нулю; было бы совершенно\linebreak
неразумно, с точки зрения информатики, представлять матрицу боль-\linebreak
ших размеров, например, $1000\times 1000$, с помощью массива в миллион\linebreak
клеток, если всего лишь 10000 элементов не равны нулю. Следователь-\linebreak
но,  если  все  программы,  составленные  для  работы  с  матрицами, ис-\linebreak
пользуют понятие индексируемого типа, то эти программы становятся\linebreak
полностью непригодными, когда хотят применить их алгоритмы к раз-\linebreak
реженным матрицам. Иначе говоря, программы слишком зависимы от\linebreak
внутреннего представления обрабатываемых объектов.\newline
\hspace*{15pt}Конкретно, этот тип  представления обязывает программиста вы-\linebreak
ражать присваивание и оценку элемента матрицы, соответственно, по-\linebreak
средством вызова процедуры и функции, даже если это, возможно, бу-\linebreak
дет тяжелее записывать (что справедливо лишь отчасти). Конструктор\linebreak 
обозначен $Set\_Coefficient$, а селектор $- Coefficient\_Of$ со спецификаци-\linebreak
ями, которые мы увидим в пакете, представленном далее.\newline
\hspace*{15pt}Этих двух операций недостаточно, чтобы выполнить все возможные\linebreak
манипуляции на матрице; не хватает селекторов, позволяющих узнать\linebreak
размер матриц, чтобы знать, какие элементы существуют. Так как тон-\linebreak
кая структура матрицы совершенно не известна пользователю матрицы\linebreak
(но не разработчику, роль которого мы сейчас выполняем), невозможно\linebreak
использовать различные атрибуты массива, как в предыдущем разделе\linebreak
а нужно явно задать функции, позволяющие оценить границы матри-\linebreak
цы: $First\_Row, Last\_Row, First\_Column, Last\_Column$.\newline
\hspace*{15pt}Чтобы модуль был как можно более автономным, нужно предусмо-\linebreak
треть  и  классифицировать  возможные ошибки  и  сопоставить им ис-\linebreak
ключения.  В случае матрицы единственная ошибка обработки $-$ это\linebreak
ссылка  на  несуществующий  элемент;  эту  ошибку  символизирует  ис-\linebreak
ключение $Index\_Out\_Of\_Bounds$, которое может появиться только при\linebreak
выполнении простейших операций $Set\_Coefficient$ и $Coefficient\_Of$.\newline
Вот полная спецификация настраиваемого пакета, реализующего аб-\linebreak
страктный тип данных.
\begin{center}
\textit{Матрица с целыми элементами}
\end{center}
\begin{lstlisting}[mathescape=true, language=Ada]
generic
 type $Row\_Index$ is range <>;
 type $Column\_Index$ is range <>;
 type $Coefficient$ is range <>;
\end{lstlisting}
\newpage
%                                  71
\begin{lstlisting}[mathescape=true, language=Ada]
package $Matrix\_Nonsparse\_Integer$ is
 type $Matrix (First\_Row : Row\_Index; Last\_Row : Row\_Index;$
      $First\_Column : Column\_Index; Last\_Column : Column\_Index)$ is private;
 procedure $Set\_Coefficient (Of\_The\_Matrix :$ in out $Matrix$;
                     $At\_Row :$ in $Row\_Index$;
                     $And\_Column :$ in $Column\_Index$;
                     $To\_The\_Value :$ in $Coefficient)$;
 function $Coefficient\_Of (The\_Matrix : Matrix$;
                     $At\_Row : Row\_Index$;
                     $And\_Column : Column\_Index)$ return $Coefficient$;            
 function $First\_Row (Of\_The\_Matrix : Matrix)$ return $Row\_Index$;
 function $Last\_Row (Of\_The\_Matrix : Matrix)$ return $Row\_Index$;
 function $First\_Column (Of\_The\_Matrix : Matrix)$ return $Column\_Index$;
 function $Last\_Column (Of\_The\_Matrix : Matrix)$ return $Column\_Index$;
 
 $Index\_Out\_Of\_Bounds :$ exception;
 
private
 type $Matrix\_Template$ is
     array$(Row\_Index$ range <>,$Column\_Index$ range <>$)$ of $Coefficient$;
 type $Matrix (First\_Row : Row\_Index; Last\_Row : Row\_Index;$
            $First\_Column : Column\_Index; Last\_Column : Column\_Index)$
 is record
  $The\_Coefficient :$
     $Matrix\_Template (First\_Row .. Last\_Row, First\_Column .. Last\_Column)$;
 end record;
 pragma $Inline (Set\_Coefficient, Coefficient\_Of,$
             $First\_Row, Last\_Row, First\_Column, Last\_Column)$;
end $Matrix\_Nonsparse\_Integer$;
\end{lstlisting}

Первое замечание касается имени пакета, $Matrix\_Nonsparse\_Integer$.\linebreak
В  этом  имени  соблюдаются  простейшие  правила  построения:  первый\linebreak
радикал означает,  что  абстрактный  тип  данных,  который в  нем  опре-\linebreak
делен, $-$ матрица, второй, что эти матрицы не разреженные  (алгорит-\linebreak
мы  доступа  к  разреженным  матрицам,  в  основном,  другие),  и,  нако-\linebreak
нец, суффикс указывает на тип элементов. Это имя позволяет сразу же\linebreak
узнать примерные характеристики  определенного объекта\footnote{
Эта  проблема  может  показаться  устаревшей,  но  в  программировании  выбор\linebreak
идентификаторов $-$ важная и  тонкая операция, и  некоторые труды по  разработке\linebreak
технологии программного обеспечения посвящают этой проблеме целую  главу.}.\newline
Рассмотрим теперь видимую часть этой спецификации  (т.е.  все то,\linebreak
что предшествует  ключевому слову \textbf{private}). Прежде  всего,  формаль-\linebreak
%                                  72
\noindent
ных параметров  настройки  три  и  их  семантика  должна  быть ясной...\linebreak
Читатель педантичный  (и усидчивый, см. раздел 3.3) сможет нас упрек­-\linebreak
нуть  в  том,  что мы  не  определили,  что элементы  — личного типа  (т.е.\linebreak
почти  любого),  это  позволило  бы  обрабатывать одинаковым  способом\linebreak
матрицы  целых  чисел,  чисел  с  плавающей  запятой,  многочленов и  т.д.\linebreak
Этот выбор  основан  на  том,  что  обычно  не  совершают  один  и  тот же\linebreak
тип  вычислений  и  на матрицах с целыми  и  на  матрицах с  действитель­-\linebreak
ными  элементами  и  что  алгоритмы  вычисления  на  матрицах  много­-\linebreak
членов  не являются  простым  применением  в  кольце  многочленов  алго­-\linebreak
ритмов  для  матриц  с  элементами  из  числового  кольца.  Другими  сло­-\linebreak
вами,  алгоритмы  вычисления  на  алгебраических  структурах  соответ­-\linebreak
ствуют  структурному  типу,  который  подлежит  обработке.  Например,\linebreak
если $A-$ матрица и  если a мы хотим вычислить $A^n$,  то  для этого можно\linebreak 
взять  великолепную  настраиваемую  функцию  дихотомического  возве­-\linebreak
дения в степень,  изученную в разделе 3.3; но намного более экономично,\linebreak
при условии,  что $n-$ достаточно большое, вычислить характеристиче-\linebreak
ский  многочлен (или  минимальный,  если  умеем  его  вычислять) от $A$  и\linebreak 
прежде,  чем  вычислить  произведения  матриц,  привести  $A^n$  по  модулю \linebreak
этого  многочлена.  Все  эти  примеры  показывают,  что  можно  фиксиро­-\linebreak
вать  тип  элементов  матрицы:  что  теряем  в  общем,  то  выигрываем  в\linebreak
полезном...\\

Собственно  спецификация  начинается  с  определения  личного  типа\linebreak
$Matrix$, который обладает четырьмя дискриминантами с красноречивы-\linebreak
ми  именами.  Когда этот пакет  получит  начальные значения, тогда бу-\linebreak
дет возможно описать, например, переменную $\blacktriangleright A:Matrix(2,4,3,7);\blacktriangleleft$
это  означает,  что  $A-$ это  матрица  $3\times 5$,  у  которой  индексы  строчек\linebreak 
находятся  в  интервале  $[2,4]$,  а  индексы  столбцов  $-$  в  интервале  $[3,7]$.\linebreak 
Конкретизация  этого  пакета  порождает  не  единственный  матричный\linebreak
тип, а, скорее,  класс матриц, имеющих некоторые общие характеристи-\linebreak
ки  (тип  индексов  и  конкретный  тип  элементов).  Преимущество  этого\linebreak
способа  действия  состоит  в  том,  что  он  позволяет  обрабатывать  ма-\linebreak
трицы  различных  размеров,  исходя  только из  начальных значений.\\

Перейдем  теперь  к  точному  определению  типа $Matrix-$ определе-\linebreak
нию,  которое  обычному,  среднему  пользователю знать  необязательно.\linebreak 
Так  как  реализуются  <<полные>>  матрицы,  внутреннее  представление  ис-\linebreak
пользует  двумерные  массивы.  Но  синтаксис  языка  Ада  предписывает,\linebreak
чтобы  определение  типа,  фигурирующее  в  личной  части,  имело  то же\linebreak
начало,  что присутствует  у  него  в спецификации.  Следовательно, этот\linebreak
тип  должен  быть  типом  дискриминанта  записи,  его  единственное  по-\linebreak
ле  (отличное от  дискриминантов)  $-$ это двумерный  массив,  о котором\linebreak
\newpage
\end{document} 