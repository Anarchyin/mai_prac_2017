\documentclass{../../template/mai_book}

\defaultfontfeatures{Mapping=tex-text}
\setdefaultlanguage{russian}

\begin{document}
мы говорили. На распечатке спецификации можно увидеть определения
типов, которые должны быть представлены в личной части.
Все это может показаться невероятно сложным и неэффективным.
Это действительно сложно для того, кто не имеет достаточного опыта
в программировании. Эта сложность кажется бесполезной тому, кто
никогда не пытался повторно использовать свои программы в контек­
стах, слегка отличных от контекста разработки: с опытом приходит
понимание, что эту цену необходимо платить один только раз — лишь
во время первого написания. Некоторые могут еще сослаться на то,
что теряется четкость: пишем \textit{►~Set-Coefficient (A, i, j,\dots)~◄} вместо
\textit{►~A(i,j) := \dots~◄}. И опять, все это вопрос опыта: если стиль — однород­
ный, программы читаются так же легко, как и программы, записанные
обычным способом.
В том, что касается эффективности, язык Ада предоставляет нам
некоторые средства, позволяющие влиять на скорость выполнения про­
грамм или на объем их памяти. Для этого компилятору передаются
указания, называемые прагмами. Возможно, что эти указания будут
безрезультатны (это зависит от используемого компилятора), но не со­
ставит большого труда их предусмотреть. Как это можно увидеть в
личной части, прагма Inline — которая указывает, что обращения к
подпрограммам \textit{Set-Coefficient, Coefficient-Of,\dots} нужно развернуть «в
строке», т.е. заменить обращения к этим подпрограммам разложением
их тела, — применима для всех простейших операций этой специфика­
ции.
Вторая фаза определения типа \textit{Matrix} — его реализация, очень про­
стая операция. Действительно, внутренняя структура представляет со­
бой двумерный массив, реализация примитивов — это перезапись про­
цедур и функций спецификации в терминах массивов. Вместо долгих
объяснений проще прямо представить тело пакета.

% TODO: code
\newpage
% TODO code

Можно сразу отметить простоту кода (нельзя по-настоящему го­
	ворить об алгоритме), но, тем не менее, нужно уточнить несколько
моментов. При определении типа мы представили некоторые ошибки,
которые могут появиться при использовании этого пакета. Следова­
тельно, надо выявить эти ошибки в теле имеющих к этому отношение
простейших операций. Для этого существует несколько способов:


\begin{itemize}  
\item в начале каждого модуля, в котором может появиться ошибка,
выполняют тест, позволяющий узнать, не произойдет ли ошибка.
Для этого нужно уметь предусмотреть все потенциальные ошибки
и надо уметь распознавать их предпосылки, что не всегда легко
и возможно;
\item другое решение состоит в том, чтобы использовать механизм ис­
ключений языка Ада, т.е. дать возможность модулям следовать
\newpage
обычному ходу их выполнения и предусмотреть в конце модуля
обработчик исключений, восстанавливающий предопределенные
исключения и распространяющий одно из исключений, которое
было определено для этого типа данных. Это второе решение,
заранее привлекательное из-за своей эффективности, — в неко­
торых реализациях языка Ада обработка исключений не требует
дополнительных издержек, пока не появятся исключения — имеет
то т недостаток, что не гарантирует связности данных. В случае
матриц, как они были только что реализованы, эта проблема не
требует особого внимания.
\end{itemize}

Исключение представляет собой асинхронное или непредусмотрен­
ное событие, которое может вызвать прекращение обработки информа­
ции, обеспечивающей связанность некоторых данных. Например, при
реализации динамических структур, связность которых обеспечивает­
ся указателями, очень важно, чтобы ошибки не возникали в момент,
когда связи между структурами несогласованы, что часто происходит
при модификациях. Если это возможно, нужно обязательно выявить по­
тенциальные ошибки перед их появлением, и следовательно, применить
первый метод.
Вновь эти проблемы возникают потому, что от пользователя хотят
скрыть истинное представление обрабатываемых объектов, при этом
маскирование информации доходит до утаивания внутренних ошибок!
Итак, находим обработчики исключений в реализации двух эле­
ментарных операций Set-Coefficient и Coefficient.Of: предопределенное
исключение Constraint-Error, возбуждаемое в случае ошибки выхода
индекса матрицы за его пределы, устраняется и далее распростра­
няется исключение Index-Out-Of-Bounds. Выполнение четырех неболь­
ших примитивов, позволяющих узнать границы матрицы, не может
вызвать ошибку, следовательно, там не должно быть никакой обра­
ботки ошибки. Мы уже встречали атрибуты, действующие на масси­
вах, в разделе 4.1, и в этих последних функциях снова находим атри­
буты First и Last, это показывает, каким образом данные атрибуты
применяются в случае многомерного массива, например, в ► re tu rn
Of-The-Matrix.The.Coefficient’First (1), < параметр атрибута First ука­
зывает номер размерности, к которой применяется First.

\begin{mynotice}
Хотя только что изученные операции на матрицах
являются, действительно, единственными элементарными опера­
циями, может случиться, что в эту спецификацию добавят опе­
рации, которые очень часто используются. Это в большинстве
\newpage
случаев очень простые операции, но которые по причинам эффек­
тивности и простоты выигрывают за счет информации о точном
представлении данных.
\end{mynotice}

\subsection{Ввод-вывод матриц}

Второй модуль обработки матриц позволит нам научиться использо­
вать один тип абстрактных данных. Для задачи, которая нас сейчас
занимает, первым необходимым нам инструментом является множе­
ство функций ввода-вывода. Такой аппарат содержит, как минимум,
процедуру чтения Get и процедуру записи Put для терминала, которых
пока достаточно.
Эти две процедуры предоставляют минимальное удобство для поль­
зователя: Put имеет параметр, позволяющий задать размер поля для
вывода элементов матрицы, которую хотят вывести; a Get имеет па­
раметр, который задает выводимое для ввода одной строки матрицы.
У этих двух параметров есть, однако, одна особенность: они имеют
значение по умолчанию. Благодаря этому, если выполняется команда
► Get (Моя-Матрица);
при отсутствии второго параметра в вызове,
программа будет использовать его значение по умолчанию, и никако­
го приглашения при чтении матрицы не появится. Зато если уточнить
► Get (Моя-Матрица,
◄ , каждое чтение одной строки будет
предваряться вопросительным знаком, позволяя пользователю знать,
где он находится. Значение по умолчанию второго параметра проце­
дуры Put есть Coefficient ’Width, результат применения предопределен­
ного атрибута Width к целому типу Coefficient: этот атрибут задает
максимальное число символов для вывода какой-либо величины типа
Coefficient.
После того как описаны средства, предлагаемые модулем, т.е. услу­
ги, которые он способен предоставить, нужно познакомиться и с услу­
гами, в которых он нуждается, чтобы реализовать все это. Эти услу­
ги появятся в качестве формальных параметров настройки и должны
быть обеспечены предыдущим пакетом. Тогда получится следующая
полная спецификация:

% TODO: code
\newpage
% TODO: code
«Это не упрощает дела!» — сразу скажет читатель. Еще раз по­
вторим сказанное: только опыт позволит судить об этом, и во время
заключительного построения будет видно, что описанный способ дей­
ствия имеет, скорее, тенденцию к упрощению архитектуры программы.
Однако сделаем несколько уточнений:
\begin{itemize}
\item процедуры ввода-вывода нуждаются в информации о типе Ma­
trix, и поскольку он определен как личный тип, то здесь он тоже
должен быть объявлен личным;
\item для считывания и записи должны быть известны границы обра­
батываемых матриц, так же как и природа элементов, ибо, в ко­
нечном счете, именно над ними производятся действия; это объ­
ясняет присутствие первых четырех параметров настройки;
\item наконец, нужно ввести все примитивы, определенные в предыду­
щем разделе.
\end{itemize}

Данная спецификация, которая кажется довольно громоздкой, полна
и очень мало связана с другими модулями. Это означает, что исполь­
зовать указанный модуль весьма просто и что модификации описания
типа абстрактных данных Matrix или других тяготеющих к нему мо­
дулей мало скажутся на этом особом модуле.

\newpage

Приводим реализацию описанной процедуры, которая пока не пред­
ставляет никакой особой трудности.

% TODO: code

Отметим способ, с помощью которого здесь используются примити­
вы работы с матрицами, а также ассоциацию по именам фактических
параметров самих этих примитивов. Сделаем последнее замечание, ка­
сающееся имени рассмотренного пакета: что хоть и следует избегать
этого в общем случае, в данном идентификаторе используют аббреви­
атуру 10 — общепринятый акроним, означающий Input/Output, как,
например, в TextJO.

\subsection{Описание генератора биекций}

Перейдем теперь к вычислению определителя матрицы, пользуясь фор­
мулой определения 7 в начале раздела 4 и предполагая, что мы обладаем

\newpage

генератором биекций между двумя целыми интервалами. Реализация
самого генератора отнесена в конец главы, чтобы не отвлекаться от
нашей первоначальной задачи.
Даже если на время не стоит вопрос о деталях построения генера­
тора перестановок, нужно, по крайней мере, знать способ его примене­
ния и инструменты, которые он предлагает, — короче, его описание.
Первый шаг на этом пути — выбор структуры данных, допускающей
представление одной перестановки. Существует несколько стандарт­
ных обозначений для перестановок: в форме произведения циклов, в
форме таблицы, представляющей граф перестановки, и т.п. Например,
перестановка $\delta$ интервала [1,5], определенная равенствами $\delta(1)~=~2,
\delta(2) = 4, \delta(3) = 5, \delta(4) = 1 и \delta(5) = 3$, представляется в форме про­
изведения циклов как: $\delta = ( 1 2 4 )( 3 5 )$, а в форме таблицы, как
%$\delta$ \begin{matrix} \end{matrix}

\end{document}